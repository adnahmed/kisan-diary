import {
  Avatar,
  ChatContainer,
  Conversation,
  ConversationHeader,
  ConversationList,
  MainContainer,
  Message,
  MessageGroup,
  MessageInput,
  MessageList,
  Sidebar,
  TypingIndicator,
} from "@chatscope/chat-ui-kit-react";
import chatoscopeStyles from "@chatscope/chat-ui-kit-styles/dist/default/styles.min.css";
import type { MessageContent, TextContent } from "@chatscope/use-chat";
import {
  AutoDraft,
  BasicStorage,
  ChatMessage,
  ChatProvider,
  MessageContentType,
  MessageDirection,
  MessageStatus,
  Presence,
  User,
  UserStatus,
  useChat,
} from "@chatscope/use-chat";
import type { LinksFunction } from "@remix-run/node";
import { useCatch } from "@remix-run/react";
import { nanoid } from "nanoid";
import { useCallback, useEffect, useMemo } from "react";
import createConversation from "~/helpers/createConversation";
import { serviceFactory } from "~/services/serviceFactory.client";
export const links: LinksFunction = () => {
  return [{ rel: "stylesheet", href: chatoscopeStyles }];
};
interface MessageProps {
  user: User;
}
export function Chat({ user }: MessageProps) {
  // Get all chat related values and methods from useChat hook
  const {
    currentMessages,
    conversations,
    activeConversation,
    setActiveConversation,
    sendMessage,
    getUser,
    currentMessage,
    setCurrentMessage,
    sendTyping,
    setCurrentUser,
  } = useChat();

  useEffect(() => {
    setCurrentUser(user);
  }, [user, setCurrentUser]);

  // Get current user data
  const [currentUserAvatar, currentUserName] = useMemo(() => {
    if (activeConversation) {
      const participant =
        activeConversation.participants.length > 0
          ? activeConversation.participants[0]
          : undefined;

      if (participant) {
        const user = getUser(participant.id);
        if (user) {
          return [<Avatar src={user.avatar} />, user.username];
        }
      }
    }

    return [undefined, undefined];
  }, [activeConversation, getUser]);

  const handleChange = (value: string) => {
    // Send typing indicator to the active conversation
    // You can call this method on each onChange event
    // because sendTyping method can throttle sending this event
    // So typing event will not be send to often to the server
    setCurrentMessage(value);
    if (activeConversation) {
      sendTyping({
        conversationId: activeConversation?.id,
        isTyping: true,
        userId: user.id,
        content: value, // Note! Most often you don't want to send what the user types, as this can violate his privacy!
        throttle: true,
      });
    }
  };

  const handleSend = (text: string) => {
    const message = new ChatMessage({
      id: "", // Id will be generated by storage generator, so here you can pass an empty string
      content: text as unknown as MessageContent<TextContent>,
      contentType: MessageContentType.TextHtml,
      senderId: user.id,
      direction: MessageDirection.Outgoing,
      status: MessageStatus.Sent,
    });

    if (activeConversation) {
      sendMessage({
        message,
        conversationId: activeConversation.id,
        senderId: user.id,
      });
    }
  };

  const getTypingIndicator = useCallback(() => {
    if (activeConversation) {
      const typingUsers = activeConversation.typingUsers;

      if (typingUsers.length > 0) {
        const typingUserId = typingUsers.items[0].userId;

        // Check if typing user participates in the conversation
        if (activeConversation.participantExists(typingUserId)) {
          const typingUser = getUser(typingUserId);

          if (typingUser) {
            return (
              <TypingIndicator content={`${typingUser.username} is typing`} />
            );
          }
        }
      }
    }

    return undefined;
  }, [activeConversation, getUser]);

  return (
    <MainContainer
      responsive
      style={{
        height: "500px",
        width: "500px",
      }}
    >
      <Sidebar position="left" scrollable>
        <ConversationHeader style={{ backgroundColor: "#fff" }}>
          <Avatar src={""} />
          <ConversationHeader.Content>{user.email}</ConversationHeader.Content>
        </ConversationHeader>
        <ConversationList>
          {conversations.map((c) => {
            // Helper for getting the data of the first participant
            const [avatar, name] = (() => {
              const participant =
                c.participants.length > 0 ? c.participants[0] : undefined;

              if (participant) {
                const user = getUser(participant.id);
                if (user) {
                  return [<Avatar src={user.avatar} />, user.username];
                }
              }

              return [undefined, undefined];
            })();

            return (
              <Conversation
                key={c.id}
                name={name}
                info={
                  c.draft
                    ? `Draft: ${c.draft
                        .replace(/<br>/g, "\n")
                        .replace(/&nbsp;/g, " ")}`
                    : ``
                }
                active={activeConversation?.id === c.id}
                unreadCnt={c.unreadCounter}
                onClick={() => setActiveConversation(c.id)}
              >
                {avatar}
              </Conversation>
            );
          })}
        </ConversationList>
      </Sidebar>

      <ChatContainer>
        {activeConversation && (
          <ConversationHeader>
            {currentUserAvatar}
            <ConversationHeader.Content userName={currentUserName} />
          </ConversationHeader>
        )}
        <MessageList typingIndicator={getTypingIndicator()}>
          {activeConversation &&
            currentMessages.map((g) => (
              <MessageGroup key={g.id} direction={g.direction}>
                <MessageGroup.Messages>
                  {g.messages.map((m: ChatMessage<MessageContentType>) => (
                    <Message
                      key={m.id}
                      model={{
                        type: "html",
                        payload: m.content,
                        direction: m.direction,
                        position: "normal",
                      }}
                    />
                  ))}
                </MessageGroup.Messages>
              </MessageGroup>
            ))}
        </MessageList>
        <MessageInput
          value={currentMessage}
          onChange={handleChange}
          onSend={handleSend}
          disabled={!activeConversation}
          attachButton={false}
          placeholder="Type here..."
        />
      </ChatContainer>
    </MainContainer>
  );
}
const messageIdGenerator = (message: ChatMessage<MessageContentType>) =>
  nanoid();
const groupIdGenerator = () => nanoid();

const akaneStorage = new BasicStorage({ groupIdGenerator, messageIdGenerator });
const eliotStorage = new BasicStorage({ groupIdGenerator, messageIdGenerator });
const emilyStorage = new BasicStorage({ groupIdGenerator, messageIdGenerator });
const joeStorage = new BasicStorage({ groupIdGenerator, messageIdGenerator });
export const akaneModel = {
  name: "Adnan",
  avatar: "",
};

export const eliotModel = {
  name: "Sulman",
  avatar: "",
};

export const emilyModel = {
  name: "Faizan",
  avatar: "",
};

export const joeModel = {
  name: "Kauser",
  avatar: "",
};
const users = [akaneModel, eliotModel, emilyModel, joeModel];
const chats = [
  { name: "Adnan", storage: akaneStorage },
  { name: "Sulman", storage: eliotStorage },
  { name: "Faizan", storage: emilyStorage },
  { name: "Kauser", storage: joeStorage },
];
const akane = new User({
  id: akaneModel.name,
  presence: new Presence({ status: UserStatus.Available, description: "" }),
  firstName: "",
  lastName: "",
  username: akaneModel.name,
  email: "",
  avatar: akaneModel.avatar,
  bio: "",
});

const emily = new User({
  id: emilyModel.name,
  presence: new Presence({ status: UserStatus.Available, description: "" }),
  firstName: "",
  lastName: "",
  username: emilyModel.name,
  email: "",
  avatar: emilyModel.avatar,
  bio: "",
});

const eliot = new User({
  id: eliotModel.name,
  presence: new Presence({ status: UserStatus.Available, description: "" }),
  firstName: "",
  lastName: "",
  username: eliotModel.name,
  email: "",
  avatar: eliotModel.avatar,
  bio: "",
});

const joe = new User({
  id: joeModel.name,
  presence: new Presence({ status: UserStatus.Available, description: "" }),
  firstName: "",
  lastName: "",
  username: joeModel.name,
  email: "",
  avatar: joeModel.avatar,
  bio: "",
});
// Add users and conversations to the states
chats.forEach((c) => {
  users.forEach((u) => {
    if (u.name !== c.name) {
      c.storage.addUser(
        new User({
          id: u.name,
          presence: new Presence({
            status: UserStatus.Available,
            description: "",
          }),
          firstName: "",
          lastName: "",
          username: u.name,
          email: "",
          avatar: u.avatar,
          bio: "",
        })
      );

      const conversationId = nanoid();

      const myConversation = c.storage
        .getState()
        .conversations.find(
          (cv) =>
            typeof cv.participants.find((p) => p.id === u.name) !== "undefined"
        );
      if (!myConversation) {
        c.storage.addConversation(createConversation(conversationId, u.name));

        const chat = chats.find((chat) => chat.name === u.name);

        if (chat) {
          const hisConversation = chat.storage
            .getState()
            .conversations.find(
              (cv) =>
                typeof cv.participants.find((p) => p.id === c.name) !==
                "undefined"
            );
          if (!hisConversation) {
            chat.storage.addConversation(
              createConversation(conversationId, c.name)
            );
          }
        }
      }
    }
  });
});
export default function Messages() {
  return (
    <div className="flex wrap">
      <div></div>
      <ChatProvider
        serviceFactory={serviceFactory}
        storage={akaneStorage}
        config={{
          typingThrottleTime: 250,
          typingDebounceTime: 900,
          debounceTyping: true,
          autoDraft: AutoDraft.Save | AutoDraft.Restore,
        }}
      >
        <Chat user={akane} />
      </ChatProvider>
      <ChatProvider
        serviceFactory={serviceFactory}
        storage={eliotStorage}
        config={{
          typingThrottleTime: 250,
          typingDebounceTime: 900,
          debounceTyping: true,
          autoDraft: AutoDraft.Save | AutoDraft.Restore,
        }}
      >
        <Chat user={eliot} />
      </ChatProvider>
    </div>
  );
}

export function ErrorBoundary({ error }: { error: Error }) {
  return (
    <div>
      <h1>Error</h1>
      <p>{error.message}</p>
      <p>The stack trace is:</p>
      <pre>{error.stack}</pre>
    </div>
  );
}

export function CatchBoundary() {
  const caught = useCatch();

  return (
    <div>
      <h1>Caught</h1>
      <p>Status: {caught.status}</p>
      <pre>
        <code>{JSON.stringify(caught.data, null, 2)}</code>
      </pre>
    </div>
  );
}
